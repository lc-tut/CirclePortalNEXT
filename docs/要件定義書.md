# CirclePortal 要件定義書 & DB設計書

2025-12-05 17:34

## 1. プロジェクト概要

### 1.1. サービス目的

大学のサークル（クラブ・部活・同好会）情報を集約し、学生および学外（受験生等）へ可視化するWebサービス。
情報の鮮度を保つため、**「各サークルの担当者が自律的に情報を更新できる」** ことを最大の強みとする。

### 1.2. ターゲットユーザー

1.  **閲覧者 (Guest):** 受験生、在学生。サークルを探している人。
2.  **サークル管理者 (Circle Admin):** 各サークルの代表・広報担当。情報の更新を行う。
3.  **システム管理者 (System Admin):** 学務課、およびLinuxClub等の運用担当。サークルの承認・停止、全体のお知らせ管理を行う。

-----

## 2. システムアーキテクチャ・技術選定

初心者（学部1\~2年生）でもメンテナンスが可能であり、かつモダンな学習効果の高い構成を採用する。

### 2.1. 技術スタック

| カテゴリ | 技術選定 | 選定理由 |
| :--- | :--- | :--- |
| **Frontend** | **Next.js (App Router)** | 動的なOGP生成、モダンなUI構築のため。表示ロジックに専念する。(バックエンド的な処理・ロジックは組まない) |
| **Backend** | **Python (FastAPI)** | CS学部必修言語(Python)の活用。型安全性とSwagger UIによるAPI定義の明確化。 |
| **Database** | **PostgreSQL** | 堅牢なRDBMS。配列型やJSON型など高度な機能も利用可能。 |
| **ORM** | **SQLModel** | SQLAlchemy + Pydantic。DB定義とAPI型定義を一元管理し、二重管理を防ぐ。 |
| **Infra** | **Docker Compose** | (初期) オンプレサーバでの簡易運用。(将来的にk8sへ移行の可能性有)|
| **UI Lib** | **shadcn/ui + Tailwind** | デザイン担当不在でも、高品質かつ統一感のあるUIを(できるだけ)迅速に構築するため。 |

### 2.2. システム構成図 (概念)

```mermaid
graph LR
    User[ユーザー] -->|HTTPS| NextJS[Next.js - Frontend]
    Guest[未ログインユーザー] -->|HTTPS| Static[静的サイト - 外部公開用]
    NextJS -->|REST API - JSON| API[FastAPI - Backend]
    API -->|SQLModel - Async| DB[PostgreSQL]
    API -->|Mount| Storage[Local Storage - Images]
    API -->|月次更新| Static
```

**注意:**
- **外部公開ページ**: 未ログインユーザー向けに、DBから必要データのみを取り出して静的サイトとしてレンダリング
  - 事実上別サービス扱い (リンクも分ける)
  - 更新頻度: 月次 (1ヶ月に1回程度)
  - メリット: パフォーマンス向上、DB負荷軽減、SEO対策

-----

## 3. 機能要件

### 3.1. 認証・認可方針

#### 3.1.1. 技術選定

  * **認証基盤:** **Keycloak 26 (最新LTS)**
      * バージョン 26 LTS を使用し、OpenID Connect (OIDC) により、フロントエンド・バックエンド双方で JWT を利用可能にする
      * バージョン 17 以降の設定方式を採用 (`client_secret` による認証、`code flow` との組み合わせ)
  * **JWT (JSON Web Token):** OIDC Token の一部として、Keycloak が発行
  * **権限管理:** ハイブリッド構成を採用
      * **システム管理者権限** → Keycloak の Role で管理 (`system_admin`)
      * **サークル編集権限** → アプリDB (`CircleMembers` テーブル) で管理 (Leader/Editor/Member)

#### 3.1.2. フェーズ別展開方針

**フェーズ1 (開発初期):**

  * Keycloak (v26 LTS) を Docker Compose で起動 (`mise run infra` で自動起動)
  * ローカル環境での認証フローを実装・検証
  * デフォルトレルム `CirclePortal-dev` を作成
  * サンプルユーザーを複数登録し、権限の切り替えテストを実施

**フェーズ2 (本番運用):**

  * Keycloak を本番環境にデプロイ
  * **ユーザー登録制限:** `@edu.teu.ac.jp` ドメインのメールのみ登録許可
      * Keycloak のユーザーフェデレーション (User Federation) または LDAP 連携で実装
  * **管理者アカウント:** `@edu.teu.ac.jp` 以外のドメイン (例: `admin@lcn.ad.jp`) も システム管理者として登録可能
  * 本番レルム (`CirclePortal-prod`) を作成し、開発環境と分離

#### 3.1.3. 認証フロー (OpenID Connect Authorization Code Flow)

```mermaid
sequenceDiagram
    participant User as ユーザー<br/>(Browser)
    participant FE as Frontend<br/>(Next.js)
    participant KC as Keycloak
    participant API as Backend API<br/>(FastAPI)
    participant DB as Database

    User->>FE: ① ログイン画面にアクセス
    FE->>KC: ② Authorization Code Flow 開始<br/>(client_id, redirect_uri, scope)
    KC->>User: ③ ログイン画面を表示
    User->>KC: ④ メール・パスワード入力
    KC->>FE: ⑤ Authorization Code を返す<br/>(リダイレクト)
    FE->>KC: ⑥ Authorization Code + client_secret<br/>を使用してトークン交換
    KC->>FE: ⑦ JWT (access_token, id_token, refresh_token) を発行
    FE->>FE: ⑧ Session に保存 (httpOnly Cookie)
    
    Note over FE: ユーザーがサークル情報を編集しようとする
    
    FE->>API: ⑨ PUT /circles/{id}<br/>Authorization: Bearer {access_token}
    API->>API: ⑩ JWT の署名検証<br/>(Keycloak 公開鍵で検証)
    API->>API: ⑪ ユーザー情報抽出<br/>(sub, email, roles)
    API->>DB: ⑫ CircleMembers テーブルで<br/>編集権限を確認
    alt 権限あり
        API->>DB: ⑬ Circle レコード更新
        API-->>FE: ⑭ 200 OK
    else 権限なし
        API-->>FE: ⑭ 403 Forbidden
    end
```

**フロー解説:**

1. **Frontend (Next.js) がログイン画面へ誘導** (①②)
   - ユーザーが未認証状態で `/circles/[id]/edit` にアクセスすると、ログインページにリダイレクト
   - Keycloak の Authorization Code Flow を開始

2. **Keycloak がユーザー認証を処理** (③④)
   - Keycloak が認証画面を表示
   - ユーザーが メール (username) とパスワードを入力
   - 認証情報を検証

3. **Frontend がトークンを取得** (⑤⑥⑦)
   - 認証成功後、Frontend に Authorization Code が返される
   - Frontend の Server側 (Node.js サーバー側) で、Authorization Code と `client_secret` を使用してトークンと交換
   - **重要:** `client_secret` は Frontend の環境変数で管理し、**ブラウザに公開しない**
   - Keycloak がアクセストークン (JWT)、ID Token、リフレッシュトークンを発行

4. **Token を Session で管理** (⑧)
   - アクセストークンを `httpOnly` Cookie に保存
   - ブラウザの JavaScript からはアクセス不可（CSRF攻撃対策）

5. **API リクエストに Token を付与** (⑨)
   - Frontend は Server Component から API を呼び出す際、Session のトークンを `Authorization: Bearer <token>` ヘッダに含める

6. **Backend API が Token を検証** (⑩⑪⑫)
   - FastAPI の Dependency で JWT を検証
   - Keycloak の公開鍵で署名を確認
   - ユーザーID (sub)、メール、Roles を抽出
   - DB で追加の権限チェック (サークル編集権限)

#### 3.1.4. レルム運用方針

**レルム (Realm):** Keycloak におけるユーザー・ロール・クライアントの独立した管理単位

**運用構成:**

| 用途 | レルム名 | 目的 | ユーザー登録 |
|------|---------|------|------------|
| **開発環境** | `CirclePortal-dev` | ローカル開発・テスト | 誰でも可能 |
| **本番環境** | `CirclePortal-prod` | 運用環境 | `@edu.teu.ac.jp` のみ |

**各レルムの設定:**

1. **Client (OAuth Application) 設定**
   - **Client ID:** `circle-portal-frontend` (Frontend 用)
   - **Client Secret:** 環境変数で管理 (本番環境でのみ使用)
   - **Redirect URIs:** 
     - Dev: `http://localhost:3000/api/auth/callback`
     - Prod: `https://portal.circles.lcn.ad.jp/api/auth/callback`
   - **Access Type:** Confidential (Backend での client_secret 使用)
   - **Authorization Flow:** Authorization Code Flow with PKCE (推奨)

2. **Role (ロール) 定義**
   - `system_admin` - システム全体の管理権限
   - `general` - 一般ユーザー (デフォルト)

3. **User Federation (将来実装)**
   - (絶対無理)本番環境では、学務システムの LDAP と連携できるのがベスト

#### 3.1.5. JWT トークンの内容

Keycloak が発行する JWT には、以下の情報が含まれます。

**アクセストークン (access_token) の Payload 例:**

```json
{
  "iss": "http://keycloak:8080/realms/CirclePortal-dev",
  "sub": "550e8400-e29b-41d4-a716-446655440000",
  "email": "user@edu.teu.ac.jp",
  "email_verified": true,
  "name": "Taro Yamada",
  "resource_access": {
    "circle-portal-frontend": {
      "roles": ["system_admin", "general"]
    }
  },
  "iat": 1702099200,
  "exp": 1702102800
}
```

**Backend での抽出処理:**

  * `sub` → Users テーブルの `auth_user_id` として保存
  * `email` → Users テーブルの `email` と照合
  * `resource_access.circle-portal-frontend.roles` → システム権限判定

#### 3.1.6. Pythonコード側での認証処理

**Backend (FastAPI) では、JWT を検証する Dependency を実装:**

```python
# backend/app/core/security.py (概要)

from fastapi import Depends, HTTPException
from jose import JWTError, jwt
import httpx

async def get_current_user(token: str = Depends(oauth2_scheme)) -> dict:
    """
    JWT トークンを検証し、ユーザー情報を抽出する。
    Keycloak の公開鍵を使用して署名を確認。
    """
    try:
        # Keycloak の JWKS エンドポイントから公開鍵を取得
        # (キャッシュして毎回の取得を避ける)
        payload = jwt.decode(token, public_key, algorithms=["RS256"])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise HTTPException(status_code=401)
        return payload
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")


@require_role("system_admin")  # デコレータで権限チェック
async def create_circle(...):
    # システム管理者のみ実行可能
    pass
```

**ポイント:**
  * Python コード側では、JWT を検証するのみで、Keycloak と直接通信しない
  * Keycloak の JWKS (公開鍵セット) を一度取得してキャッシュし、毎回の署名検証に使用
  * System Role は JWT の `resource_access` から抽出、Circle Role は DB の CircleMembers テーブルから取得

### 3.2. 主要機能リスト

| 機能 | 概要 | 備考 |
| :--- | :--- | :--- |
| **サークル一覧・検索** | キャンパス別(八王子/蒲田)、カテゴリ別 | フリーワード検索対応 |
| **サークル詳細表示** | 活動内容、活動場所、SNSリンク、新歓情報の表示 | **動的OGP**を生成しSNSシェアに対応 |
| **サークル編集** | サークル管理者が自団体の情報を更新 | 画像アップロード含む |
| **お知らせ管理** | 新歓、合宿、学祭等のお知らせ情報登録 | イベント開催情報を含む |
| **管理者機能** | サークルアカウントの発行・承認、論理削除されたデータの復旧、ユーザーアカウント失効日の更新等 | 教務課等が休学者のexpire_at更新に使用 |

### 3.3. API設計方針

**Strict REST** に基づき設計する。

一部設計: 
| メソッド | エンドポイント | 実行権限 | 概要・挙動 |
| :--- | :--- | :--- | :--- |
| `GET` | **/circles** | **誰でも** | サークル一覧を取得する。<br>※学外ユーザーには公開用フィールドのみ返す。<br>※クエリパラメータ: `campus_id` (1-2), `category` (sports/culture/committee), `q` (フリーワード検索), `limit` (1-100, デフォルト20), `offset` (デフォルト0)<br>※レスポンスは `created_at DESC` でソートして返す。<br>※ページネーション対応 (`limit/offset`) |
| `POST` | **/circles** | **SystemAdmin** | 新規サークルを作成する。<br>※リクエストボディには`name`, `campus_id`, `category`, `leader_email`を必須とする。<br>※バックエンドは`leader_email`からユーザーUUIDを解決し、Leaderとして登録する。<br>※初期状態は非公開(`is_published=False`)、空白のサークルページが作成される。 |
| `GET` | **/circles/{id}** | **誰でも** | サークル詳細情報を取得する。<br>※学外ユーザーには公開用フィールドのみ返す。 |
| `PUT` | **/circles/{id}** | **代表者・幹部 / SystemAdmin** | サークル情報を更新する。<br>※代表者・幹部は「自分のサークル」のみ操作可能。 |
| `DELETE` | **/circles/{id}** | **代表者 / SystemAdmin** | サークルを削除する(論理削除)。<br>※代表者またはSystemAdminのみ実行可能。 |

#### 3.3.1. GET /circles に関する実装方針

**ページネーション採用理由:**
- 大量のサークルデータが存在する場合、全件取得は メモリ負荷・ネットワーク負荷・API応答時間の悪化を招く
- `limit/offset` パターンで実装し、クライアント側で効率的なページ送り対応を可能にする

**ORDER BY created_at DESC の理由:**
- ユーザーが「新しく登録されたサークル」を優先的に発見できるようにする
- サークル側に「更新することで一覧の上部に表示される」というインセンティブを与える

**検索安全性 (SQL インジェクション対策):**
- 検索クエリ (`q` パラメータ) の `%` および `_` ワイルドカード文字を正規表現でエスケープして処理
- SQLAlchemy の `ilike()` メソッドで安全にパラメータ化されたクエリを実行

**campus_id 値検証:**
- 事前定義された campus (八王子: 1、蒲田: 2) のみを受け付け、範囲外のIDを指定されても 422 Bad Request で拒否
- DBへの無駄なクエリを削減

※ `Announcement` や `User` 関連のエンドポイントも同様のポリシー（更新は権限者のみ）で実装する。

### 3.4. サークル作成フロー (詳細)

サークルの新規作成は**SystemAdminのみ**が実行できる。一般ユーザーによる自由なサークル作成は認めない。

#### 3.4.1. フロー概要

```mermaid
sequenceDiagram
    participant Admin as SystemAdmin
    participant API as Backend API
    participant DB as Database
    participant Leader as サークル代表者(Leader)

    Note over Admin: 事前準備: 代表者のユーザー登録確認<br/>(メールアドレスを把握)
    Admin->>API: POST /circles<br/>{name, campus_id, category_id, leader_email}
    API->>API: 権限チェック(SystemAdminか?)
    API->>DB: leader_email でUsersテーブルを検索
    alt ユーザーが存在しない
        API-->>Admin: 404 Not Found<br/>(User with email not found)
    end
    Note over API: leader_emailからuser_id(UUID)を取得
    API->>DB: Circleレコード作成 (is_published=False)
    API->>DB: CircleMembersレコード作成<br/>(circle_id, user_id, role_id=1[Leader])
    API-->>Admin: 201 Created {circle_id, ...}
    Note over Leader: サークルページが作成された<br/>Leaderに通知(メール等)
    Leader->>API: PUT /circles/{id}<br/>サークル情報を編集
    Leader->>API: PUT /circles/{id}<br/>{is_published: true} で公開
```

#### 3.4.2. 処理の詳細ステップ

1. **事前準備 (SystemAdmin)**
   - サークル代表者となるユーザーが既にシステムに登録されていることを確認する
   - **代表者のメールアドレスを把握する** (例: `taro.yamada@edu.teu.ac.jp`)
   - もし未登録の場合、先に代表者のユーザーアカウントを作成する (または代表者自身にサインアップしてもらう)

2. **サークル作成リクエスト (SystemAdmin → Backend)**
   - `POST /circles` を実行
   - リクエストボディ:
     ```json
     {
       "name": "LinuxClub",
       "campus_id": 1,
       "category_id": 2,
       "leader_email": "taro.yamada@edu.teu.ac.jp"
     }
     ```

3. **バックエンド処理 (Atomic Transaction)**
   - ① 実行ユーザーが`SystemAdmin`であることを確認 (sys_role_id=1)
   - ② **`leader_email`でUsersテーブルを検索し、対応するユーザーID(UUID)を取得**
     - SQL例: `SELECT id FROM users WHERE email = 'taro.yamada@edu.teu.ac.jp' AND deleted_at IS NULL`
     - ユーザーが見つからない場合は `404 Not Found` を返す
   - ③ `Circles`テーブルに新規レコードを挿入
     - `is_published` = `False` (初期状態は非公開)
     - その他のフィールド(`description`, `location`等)は空白またはNULL
   - ④ `CircleMembers`テーブルに新規レコードを挿入
     - `circle_id` = 新規作成されたサークルのID
     - `user_id` = ②で取得したUUID
     - `role_id` = `1` (Leader)
   - ⑤ トランザクションをコミット

4. **通知 (オプション・将来実装)**
   - 代表者にメールやシステム通知で「サークルページが作成されました」と伝える

5. **サークル情報の編集 (Leader)**
   - 代表者は`PUT /circles/{id}`を使って、サークルの詳細情報を編集する
   - `description`, `location`, `activity_detail`, `logo_url`等を追加

6. **公開 (Leader)**
   - 情報が整ったら、`is_published`を`true`に更新して一般公開する

#### 3.4.3. エラーハンドリング

| エラーケース | HTTPステータス | レスポンス例 |
| :--- | :--- | :--- |
| 実行ユーザーがSystemAdminでない | `403 Forbidden` | `{"detail": "Only SystemAdmin can create circles"}` |
| `leader_email`に対応するユーザーが存在しない | `404 Not Found` | `{"detail": "User with email 'xxx@edu.teu.ac.jp' not found"}` |
| `campus_id`または`category_id`が無効 | `400 Bad Request` | `{"detail": "Invalid campus_id or category_id"}` |
| 必須フィールドが欠けている | `422 Unprocessable Entity` | FastAPIのバリデーションエラー |
| `leader_email`が無効なメール形式 | `422 Unprocessable Entity` | `{"detail": "Invalid email format"}` |

-----

## 4. データベース設計 (Schema)

ORMに **SQLModel** を使用する。以下は論理モデルである。

### 4.1. マスタテーブルとEnum

参照データは以下の方針で管理する：
- **マスタテーブル**: 運用中に値の追加・変更があり得るデータ (Campuses, SystemRoles, CircleRoles)
- **Enum**: システム定義で固定的な値 (CircleCategory, AnnouncementType)

#### 4.1.1. Campuses (キャンパスマスタ)

  * `id`: Integer (PK, Auto Increment)
  * `code`: String (Unique) - 例: `hachioji`, `kamata`

**設計方針:**
- `name`カラムは不要 (処理数を軽くするため)
- 表示名はフロントエンド側で`code`からマッピングする
  - 例: `hachioji` → "八王子", `kamata` → "蒲田"

#### 4.1.2. CircleCategory (Enum)

サークルカテゴリを表す固定値。変更が想定されないためEnumで管理。

  * `sports`: 運動系
  * `culture`: 文化系
  * `committee`: 委員会

#### 4.1.3. SystemRoles (システム権限マスタ)

  * `id`: Integer (PK, Auto Increment)
  * `code`: String (Unique) - 例: `system_admin`, `general`

**設計方針:**
- `name`カラムは不要 (処理数を軽くするため)
- 表示名はフロントエンド側で`code`からマッピングする

#### 4.1.4. CircleRoles (サークル内権限マスタ)

  * `id`: Integer (PK, Auto Increment)
  * `name`: String (Unique) - 例: `Leader`, `Editor`, `Member`
  * `code`: String (Unique) - 例: `leader`, `editor`, `member`
  * `description`: String - 権限の説明
      * `Leader`: サークル代表(全権限)
      * `Editor`: 幹部(編集権限あり)
      * `Member`: 平部員(閲覧のみ)

#### 4.1.5. AnnouncementType (Enum)

お知らせ種別を表す固定値。変更が想定されないためEnumで管理。

  * `event`: イベント - イベント開催のお知らせ(新歓、合宿、学祭等)
  * `news`: ニュース - 一般的なお知らせ(活動報告、大会結果等)

### 4.2. Users (ユーザー)

サークル個別の役割とは別に、システム全体における権限を管理するカラムがある。

  * `id`: UUID (PK)
  * `username`: String
  * `email`: String (Unique)
  * `sys_role_id`: Integer (FK: SystemRoles.id) - システム全体の権限
  * `auth_user_id`: String (Nullable, Unique, Index)
      * Keycloak等の外部認証基盤のUser ID (Sub) を格納する。
  * `expire_at`: Datetime (Nullable)
      * アカウントの失効日 (この日以降はログイン不可)
      * 学籍番号から自動計算: `c0a23xxxxx` の `23` を取り出し、4年足した年の3/31を失効日にする
        - 例: c0a23xxxxx → 2027年3月31日
      * 休学の場合、教務課が`expire_at`の更新処理を行う (画面も必要)


### 4.3. Circles (サークル)

  * `id`: UUID (PK)
  * `name`: String
  * `campus_id`: Integer (FK: Campuses.id)
  * `category`: CircleCategory (Enum) - サークルカテゴリ
  * `description`: Text (紹介文)
  * `location`: String (活動場所)
  * **`activity_detail`: Text**
      * 活動日時・頻度等の詳細。
      * 例: `"毎週月曜の17時から活動。たまに水曜も集まります。"`
  * `logo_url`: String
  * `cover_image_url`: String
  * `is_published`: Boolean (公開フラグ)
  * `created_at`: Datetime
  * `updated_at`: Datetime
  * `deleted_at`: Datetime (Nullable, 論理削除)

論理削除であるため、存在するサークル一覧を返す場合 `deleted_at`がnullであることを必ず確認すること

### 4.4. CircleMembers (中間テーブル)

ユーザーとサークルの多対多リレーション。編集権限の管理に使用。
注意として、`circle_id`と`user_id`の組み合わせがユニークになるように制約が必要。

  * `circle_id`: FK (Circles.id, PK)
  * `user_id`: FK (Users.id, PK)
  * `role_id`: Integer (FK: CircleRoles.id)

**※サークル作成時の動作:**
SystemAdminが`POST /circles`でサークルを作成する際、リクエストボディの`leader_email`からUsersテーブルを検索して対応するユーザーID(UUID)を取得。そのユーザーが自動的にこのテーブルに`role_id=1` (Leader)として登録される。詳細は「3.4. サークル作成フロー」を参照。

### 4.5. Announcements (お知らせ)

サークルが発信するお知らせ情報。新歓イベント、定期公演、合宿、学祭出展等の情報を含む。

  * `id`: UUID (PK)
  * `circle_id`: FK (Circles.id)
  * `type`: AnnouncementType (Enum, Index) - お知らせ種別
  * `title`: String (お知らせタイトル)
  * `content`: Text (お知らせ本文)
  * `event_date_start`: Datetime (Nullable, イベント開始日時)
  * `event_date_end`: Datetime (Nullable, イベント終了日時)
  * `event_location`: String (Nullable, イベント開催場所)
  * `is_pinned`: Boolean (ピン留めフラグ - 重要なお知らせを上部固定)
  * `published_at`: Datetime (Nullable, 公開日時 - NULLの場合は下書き)
  * `created_at`: Datetime
  * `updated_at`: Datetime
  * `deleted_at`: Datetime (Nullable, 論理削除)
      * 親となるサークル情報の削除にも紐づく

**注意:**
- `type` でお知らせの種類を区別する (CircleCategory Enumを使用)
- イベント情報(type="event")の場合、`event_date_start`, `event_date_end`, `event_location` を使用
- 単なニュース(type="news")の場合はイベント関連フィールドはNULL

**表示順序:**
お知らせ一覧を取得する際は、以下の順序でソートする：
1. `is_pinned DESC` (ピン留めを最上部に表示)
2. `published_at DESC` (公開日時が新しい順)

INDEX: `(circle_id, is_pinned DESC, published_at DESC)` を作成してパフォーマンスを最適化すること。

## ER図
```mermaid
erDiagram
    %% マスタテーブル
    Campuses ||--o{ Circles : "has"
    SystemRoles ||--o{ Users : "assigns"
    CircleRoles ||--o{ CircleMembers : "defines"
    
    %% メインテーブル
    Users ||--o{ CircleMembers : "belongs to"
    Circles ||--o{ CircleMembers : "has members"
    Circles ||--o{ Announcements : "publishes"

    %% マスタテーブル定義
    Campuses {
        int id PK
        string code UK "hachioji/kamata"
    }
    
    SystemRoles {
        int id PK
        string code UK "system_admin/general"
    }
    
    CircleRoles {
        int id PK
        string name UK "Leader/Editor/Member"
        string code UK "leader/editor/member"
        string description "権限説明"
    }

    %% メインテーブル定義
    Users {
        UUID id PK
        string username
        string email UK
        int sys_role_id FK
        string auth_user_id UK "Keycloakのsub - Nullable"
        datetime expire_at "Nullable - 失効日"
    }

    Circles {
        UUID id PK
        string name
        int campus_id FK
        enum category "sports/culture/committee"
        text description
        string location
        text activity_detail
        string logo_url
        string cover_image_url
        boolean is_published
        datetime created_at
        datetime updated_at
        datetime deleted_at
    }

    CircleMembers {
        UUID circle_id PK, FK
        UUID user_id PK, FK
        int role_id FK
    }

    Announcements {
        UUID id PK
        UUID circle_id FK
        enum type "event/news"
        string title
        text content
        datetime event_date_start "Nullable"
        datetime event_date_end "Nullable"
        string event_location "Nullable"
        boolean is_pinned
        datetime published_at "Nullable"
        datetime created_at
        datetime updated_at
        datetime deleted_at "Nullable"
    }
```

-----

## 5. 開発・運用ルール

### 5.0. 将来拡張計画 (フェーズ3以降)

現在の設計では実装しないが、将来的に追加を検討する機能。

#### 5.0.1. 画像・ファイル管理テーブル

**目的**: 現在はCirclesテーブルに`logo_url`, `cover_image_url`を直接保持しているが、将来的にギャラリー機能や複数画像対応が必要になった場合のための設計案。

**Imagesテーブル案:**
```
Images {
  id: UUID (PK)
  circle_id: UUID (FK: Circles.id, Nullable) // サークル画像の場合
  announcement_id: UUID (FK: Announcements.id, Nullable) // お知らせ画像の場合
  image_type: String // "logo", "cover", "gallery", "announcement"
  file_path: String
  file_size: Integer
  mime_type: String
  display_order: Integer // ギャラリー表示順序
  uploaded_at: Datetime
  deleted_at: Datetime (Nullable)
}
```

**実装時の考慮事項:**
- 既存の`logo_url`, `cover_image_url`との移行戦略
- S3/MinIOへのマイグレーション手順

#### 5.0.2. SNSリンク情報管理テーブル

**目的**: Twitter, Instagram, YouTube等の複数SNSリンクを構造化して管理する。

**SocialLinksテーブル案:**
```
SocialLinks {
  id: UUID (PK)
  circle_id: UUID (FK: Circles.id)
  platform: String // "twitter", "instagram", "youtube", "facebook", "tiktok"
  url: String
  display_order: Integer // 表示順序
  created_at: Datetime
  updated_at: Datetime
}
```

**メリット:**
- SNSプラットフォームの追加がDB変更不要
- 表示順序のカスタマイズ可能
- 各SNSのアイコン表示が容易

**現状の代替案:**
- CirclesテーブルにJSON型カラムを追加 (`social_links JSONB`)
- PostgreSQLのJSONB機能で柔軟に管理

-----

### 5.1. 画像の保存

  * **初期:** Docker Volume上の特定ディレクトリ（`./static/images/`等）に保存し、Webサーバ(FastAPI or Nginx)で配信する。
  * **将来:** S3互換ストレージ (MinIO等) へ移行。URL生成ロジックは切り出しておくこと。

### 5.2. ディレクトリ構成 (Backend)

SQLModelのメリットを活かしたレイヤードアーキテクチャ。

```text
backend/
├── app/
│   ├── api/            # Router (Endpoints)
│   │   └── v1/
│   │       ├── endpoints/
│   │       │   ├── circles.py
│   │       │   ├── users.py
│   │       │   └── auth.py
│   │       └── api.py
│   ├── core/           # Config (Env vars), Security
│   ├── db/             # DB Session, Init DB
│   ├── models/         # SQLModel Classes (DB & Pydantic)
│   │   ├── user.py
│   │   ├── circle.py
│   │   └── announcement.py
│   ├── services/       # Business Logic (CRUD functions)
│   └── main.py         # Entrypoint
├── static/             # User uploaded files
├── Dockerfile
└── pyproject.toml
```

### 5.3. データの公開範囲とフィルタリング方針

本方針は、サークル詳細取得エンドポイント (`GET /circles/{id}`) におけるレスポンス制御ルールである。

セキュリティ区分を明確にし、かつフロントエンド側で「データ未登録(Null)」と「権限による非表示(Null)」を区別してUIを出し分けられるよう、以下のルールを徹底する。

#### 共通仕様: 表示モードフラグ (`view_type`)

全てのレスポンスには、現在の閲覧権限レベルを示す `view_type` フィールドを必ず含める。

  * `view_type`: String (Enum)
      * `"public"` : 学外・未ログイン向け（一部情報がマスクされている状態）
      * `"internal"` : 学内・ログイン済み向け（全情報が開示されている状態）

-----

#### 1\. 公開用ビュー (Public View)

  * **対象:** 未ログインユーザー、または学外ユーザー。
  * **挙動:**
      * `view_type` は `"public"` を返す。
      * 機密性の高いフィールド（下記「詳細項目」）は、DBにデータが存在していても強制的に `null` を返す。
  * **取得可能項目:**
      * `id`, `name`, `campus`, `category`, `description`
      * `logo_url`, `cover_image_url`
  * **制限理由:** 活動場所や詳細スケジュールは、不特定多数への公開を避け、学内関係者の安全を保護するため。

#### 2\. 詳細用ビュー (Internal Detail View)

  * **対象:** 学内メールアドレス (`@edu.teu.ac.jp`) で認証済みのユーザー。
  * **挙動:**
      * `view_type` は `"internal"` を返す。
      * 全てのフィールドにおいて、DBに保存されている値をそのまま返す。
          * ※ここで `null` が返ってきた場合、それは「本当にデータが未登録である」ことを意味する。
  * **追加される詳細項目:**
      * `location` (活動場所)
      * `activity_detail` (活動頻度・日時の詳細)
      * `created_at` / `updated_at`
      * `is_published`

-----

#### レスポンスの具体例 (イメージ)

開発者はこのJSONイメージを参考に実装すること。

**ケースA: 学外ユーザーが見た場合 (`view_type: "public"`)**
フロントエンドは `view_type` を見て、「詳細を見るにはログインしてください」等の案内を表示する。

```json
{
  "id": "123e4567-e89b-...",
  "view_type": "public",
  "name": "LinuxClub",
  "description": "Linuxを愛するサークルです。",
  "location": null,         // ★権限がないため null (実際はデータがあるかもしれない)
  "activity_detail": null   // ★権限がないため null
}
```

**ケースB: 学内ユーザーが見た場合 (`view_type: "internal"`)**
フロントエンドは `location` が `null` の場合、「活動場所未定」と表示して良い。

```json
{
  "id": "123e4567-e89b-...",
  "view_type": "internal",
  "name": "LinuxClub",
  "description": "Linuxを愛するサークルです。",
  "location": "A棟 401教室",  // ★データが見える
  "activity_detail": "毎週月曜実施"
}
```

### 5.4. 権限チェックとデータ整合性のルール

本セクションでは、APIの権限チェックおよびデータ整合性確保の基本的な考え方を示す。

#### 5.4.1. サークル作成時の権限チェック

「3.4. サークル作成フロー」で詳述したとおり、サークル作成は**SystemAdminのみ**が実行可能。
一般ユーザーによる自由なサークル作成は認めない。

#### 5.4.2. サークル編集・削除時の権限チェック

- **編集 (`PUT /circles/{id}`)**: 当該サークルのLeader/EditorまたはSystemAdminのみ実行可能
- **削除 (`DELETE /circles/{id}`)**: 当該サークルのLeaderまたはSystemAdminのみ実行可能

-----

## 6\. フロントエンド設計 (Frontend Design) [Rev.2]

本サービスは**2つのフロントエンド**で構成される:

1. **静的サイト (外部公開用)**: 未ログインユーザー(受験生・学外者)向け
   - Next.js の SSG (Static Site Generation) で生成
   - 月次更新でビルド・デプロイ
   - 基本情報のみを表示 (活動場所などの詳細は非表示)
   - ログインへの導線を設置

2. **学内アプリ**: 学内ユーザー向け
   - Keycloak認証が必須
   - 全情報の閲覧、編集・管理機能を提供
   - Server Components を主体とした設計
   - UIライブラリには **shadcn/ui** を採用

### 6.1. ディレクトリ構成

**外部公開静的サイト用** と **学内アプリ用** で別々のNext.jsプロジェクトとして管理する。

#### 6.1.1. 外部公開静的サイト (public-site/)

```text
public-site/
├── src/
│   ├── app/
│   │   ├── layout.tsx       # 全体レイアウト (シンプルなHeader/Footer)
│   │   ├── page.tsx         # トップページ
│   │   ├── circles/
│   │   │   ├── page.tsx     # サークル一覧
│   │   │   └── [id]/
│   │   │       └── page.tsx # サークル詳細 (公開情報のみ)
│   │   └── login/
│   │       └── page.tsx     # ログインページへのリダイレクト
│   ├── components/
│   │   ├── ui/              # shadcn/ui (Button, Card等)
│   │   ├── CircleCard.tsx   # サークルカード
│   │   └── LoginPrompt.tsx  # ログイン誘導バナー
│   ├── lib/
│   │   └── data-fetch.ts    # ビルド時のデータ取得
│   └── types/
├── public/
└── next.config.mjs          # output: 'export' でSSG設定
```

#### 6.1.2. 学内アプリ (frontend/)

```text
frontend/
├── src/
│   ├── app/                 # App Router
│   │   ├── layout.tsx       # 全体レイアウト (認証情報表示)
│   │   ├── page.tsx         # ダッシュボード
│   │   ├── circles/         # サークル管理
│   │   │   ├── page.tsx     # サークル一覧 (全情報)
│   │   │   ├── [id]/
│   │   │   │   ├── page.tsx         # 詳細 (全情報)
│   │   │   │   ├── edit/
│   │   │   │   │   └── page.tsx     # 編集画面
│   │   │   │   ├── announcements/   # お知らせ (サークル単位)
│   │   │   │   │   ├── page.tsx     # お知らせ一覧
│   │   │   │   │   ├── new/
│   │   │   │   │   │   └── page.tsx # お知らせ新規作成
│   │   │   │   │   └── [announcement_id]/
│   │   │   │   │       └── edit/
│   │   │   │   │           └── page.tsx # お知らせ編集
│   │   │   │   └── opengraph-image.tsx # 動的OGP
│   │   │   └── create/      # 新規作成 (SystemAdminのみ)
│   │   └── admin/           # システム管理画面
│   ├── components/
│   │   ├── ui/              # shadcn/ui
│   │   ├── features/
│   │   │   ├── CircleCard.tsx
│   │   │   ├── SearchFilter.tsx
│   │   │   └── AnnouncementList.tsx
│   │   └── layouts/         # Header, Footer, Sidebar
│   ├── lib/
│   │   ├── api.ts           # Backend API Wrapper
│   │   ├── auth.ts          # Keycloak認証
│   │   └── utils.ts
│   └── types/
├── public/
└── tailwind.config.ts
```


### 6.2. ページ構成と役割

#### 6.2.1. 静的サイト (外部公開用)

**対象ユーザー:** 未ログインユーザー (受験生、学外者、初回訪問の在学生)

##### トップページ (`/`)

**目的:** サークル情報への導線と、ログインへの誘導

  * **Primary Action:**
      * **「八王子キャンパスのサークルを見る」** (To: `/circles?campus=hachioji`)
      * **「蒲田キャンパスのサークルを見る」** (To: `/circles?campus=kamata`)
  * **Secondary Content:**
      * **「最近更新されたサークル」** セクション (4〜8件)
  * **ログイン誘導:**
      * ヘッダーに「詳細情報を見るにはログイン」ボタン
      * 学内アプリ (`https://portal-auth.example.com`) へのリンク

##### サークル一覧 (`/circles`)

**目的:** 基本情報での絞り込みとサークル発見

  * **表示内容:** サークル名、キャンパス、カテゴリ、簡単な説明
  * **機能:** キャンパス・カテゴリでの絞り込み (フリーワード検索は未実装)
  * **制限:** 活動場所や詳細情報は表示しない

##### サークル詳細 (`/circles/[id]`)

**目的:** サークルの基本情報を表示し、より詳細な情報へ誘導

  * **表示内容:**
      * サークル名、説明、キャンパス、カテゴリ
      * ロゴ・カバー画像
  * **非表示:**
      * 活動場所、活動詳細
      * 「詳細を見るにはログインしてください」と表示
  * **OGP:** 静的なOGP画像を生成 (サークル名・ロゴを含む)

#### 6.2.2. 学内アプリ

**対象ユーザー:** Keycloak認証済みの学内ユーザー

##### ダッシュボード (`/`)

**目的:** ユーザーの状況に応じた情報表示

  * **表示内容:**
      * 自分が所属するサークルの一覧とクイックアクセス
      * 最近のお知らせ
      * 所属するサークルのお知らせ
      * システム管理者の場合: 承認待ちサークル、統計情報

##### サークル一覧 (`/circles`)

**目的:** 全情報での検索・閲覧

  * **機能:**
      * フリーワード検索
      * カテゴリ・キャンパス・活動曜日での絞り込み
  * **表示内容:** 活動場所を含む全情報

##### サークル詳細 (`/circles/[id]`)

**目的:** サークルの全情報を表示

  * **表示内容:** 活動場所、活動詳細、お知らせなど全情報
  * **権限による機能:**
      * Leader/Editor: 「編集」ボタン表示
      * SystemAdmin: 「削除」「復旧」ボタン表示

##### サークル編集 (`/circles/[id]/edit`)

**権限:** 該当サークルのLeader/EditorまたはSystemAdmin

  * **編集可能項目:** 全フィールド (名前、説明、活動場所、画像など)
  * **公開設定:** `is_published` の切り替え

##### お知らせ一覧 (`/circles/[id]/announcements`)

**権限:** 全ログインユーザー (閲覧)、該当サークルのLeader/Editor (作成・編集)

**目的:** 特定サークルのお知らせを一覧表示・管理

  * **表示内容:**
      * 該当サークルのお知らせ一覧 (ピン留め対応)
      * イベント情報 (新歓、合宿、学祭等)
      * 一般的なお知らせ (活動報告、大会結果等)
  * **機能:**
      * Leader/Editor: 「新規作成」ボタン表示
      * 各お知らせの編集・削除リンク

##### お知らせ新規作成 (`/circles/[id]/announcements/new`)

**権限:** 該当サークルのLeader/Editor

**目的:** 新しいお知らせを作成

  * **入力項目:**
      * タイトル (必須)
      * 本文 (必須)
      * 種別 (event/news)
      * イベント情報 (種別がeventの場合)
        - 開催日時 (開始・終了)
        - 開催場所
      * ピン留め設定
      * 公開設定 (下書き/公開)

##### お知らせ編集 (`/circles/[id]/announcements/[announcement_id]/edit`)

**権限:** 該当サークルのLeader/Editor

**目的:** 既存のお知らせを編集

  * **編集可能項目:** 新規作成と同じ全項目
  * **追加機能:** 削除ボタン (論理削除)

##### システム管理画面 (`/admin`)

**権限:** SystemAdminのみ

  * **機能:**
      * サークル新規作成
      * サークルの論理削除・復旧
      * ユーザーの失効日更新
      * 統計情報の表示

### 6.3. 実装方針・ルール

#### 6.3.1. 静的サイトの実装方針

  * **ビルド方式:** Next.js の `output: 'export'` を使用した完全静的出力
  * **データ取得:** ビルド時にバックエンドAPIから `view_type: "public"` のデータを取得
  * **デプロイ:** 月次で `npm run build` を実行し、生成された静的ファイルを公開
  * **更新トリガー:** cron または手動実行
  * **インタラクティブ要素:** 最小限 (検索フィルタはクライアントサイドで動作)

#### 6.3.2. 学内アプリの実装方針

##### Server Components vs Client Components

  * **Server Components (Default):**
      * 認証状態の確認
      * データ取得 (`fetch` with authentication token)
      * ダッシュボード、一覧、詳細ページのレンダリング
  * **Client Components (`"use client"`):**
      * 検索フォーム、フィルタ
      * 編集フォーム
      * インタラクティブなUI要素

##### データフェッチ

  * **Read (GET):** 
      * Server Component で認証トークンを含めてAPI呼び出し
      * `view_type: "internal"` で全情報を取得
  * **Write (POST/PUT/DELETE):** 
      * Client Component からバックエンドAPIを呼び出し
      * 認証トークンを自動付与

##### 認証フロー

###### 初回アクセス時 (未認証)

1. ユーザーが `/circles/[id]/edit` など認証が必要なページにアクセス
2. Middleware で認証状態を確認し、トークンがない場合は `/login` にリダイレクト
3. `/login` ページで、「Keycloak でログイン」ボタンをクリック
4. Frontend の API Route (`/api/auth/login`) を呼び出し
5. この API Route が、Authorization Code Flow を開始

```typescript
// frontend/src/app/api/auth/login/route.ts (概要)
export async function GET(request: Request) {
  const authorizationUrl = `${KEYCLOAK_URL}/auth/realms/${REALM}/protocol/openid-connect/auth?` +
    `client_id=${CLIENT_ID}&redirect_uri=${REDIRECT_URI}&response_type=code&scope=openid`;
  
  return NextResponse.redirect(authorizationUrl);
}
```

6. Keycloak のログイン画面が表示され、ユーザーが認証
7. Keycloak が Authorization Code とともに `/api/auth/callback` にリダイレクト
8. Callback Handler が Authorization Code と `client_secret` を使用してトークンと交換

```typescript
// frontend/src/app/api/auth/callback/route.ts (概要)
export async function GET(request: Request) {
  const code = searchParams.get("code");
  
  // Server-to-Server で Keycloak にトークンをリクエスト
  const tokenResponse = await fetch(`${KEYCLOAK_URL}/token`, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: new URLSearchParams({
      grant_type: "authorization_code",
      code,
      client_id: CLIENT_ID,
      client_secret: CLIENT_SECRET, // Server 側でのみ使用
      redirect_uri: REDIRECT_URI,
    }),
  });
  
  const { access_token, refresh_token } = await tokenResponse.json();
  
  // トークンを httpOnly Cookie に保存
  response.cookies.set("access_token", access_token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
  });
  
  return NextResponse.redirect("/"); // ダッシュボードへ
}
```

9. トークンが `httpOnly` Cookie に保存され、以降の API リクエストに自動的に含まれる

###### 認証後のAPI呼び出し

- **Server Component:**
  ```typescript
  // frontend/src/app/circles/[id]/edit/page.tsx
  async function CircleEditPage({ params }: { params: { id: string } }) {
    // サーバー側で、Cookie からトークンを取得
    const token = cookies().get("access_token")?.value;
    
    const response = await fetch(`${API_BASE_URL}/circles/${params.id}`, {
      headers: { Authorization: `Bearer ${token}` },
    });
    
    const circle = await response.json();
    return <CircleEditForm circle={circle} />;
  }
  ```

- **Client Component (POST/PUT):**
  ```typescript
  // Server Action で API 呼び出し
  async function updateCircle(formData: FormData) {
    "use server";
    
    const token = cookies().get("access_token")?.value;
    const response = await fetch(`${API_BASE_URL}/circles/${id}`, {
      method: "PUT",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify(formData),
    });
    
    return await response.json();
  }
  ```

###### トークン更新 (Refresh Token)

- アクセストークンの有効期限が切れたら、リフレッシュトークンを使用して新しいアクセストークンを取得
- Middleware で定期的に確認し、必要に応じて更新

```typescript
// frontend/middleware.ts
export async function middleware(request: NextRequest) {
  const accessToken = request.cookies.get("access_token")?.value;
  const refreshToken = request.cookies.get("refresh_token")?.value;
  
  if (accessToken) {
    // JWT をデコード (署名検証なし、有効期限チェックのみ)
    const decoded = parseJwt(accessToken);
    if (decoded.exp * 1000 < Date.now()) {
      // アクセストークンが期限切れ → リフレッシュ
      const newTokens = await refreshAccessToken(refreshToken);
      response.cookies.set("access_token", newTokens.access_token);
      response.cookies.set("refresh_token", newTokens.refresh_token);
    }
  }
  
  return response;
}
```

###### ログアウト

- ユーザーが「ログアウト」ボタンをクリック
- `access_token` と `refresh_token` を削除
- (オプション) Keycloak の logout エンドポイントを呼び出し

```typescript
async function logout() {
  await fetch("/api/auth/logout", { method: "POST" });
  // Cookie 削除、トップページへリダイレクト
}
```

###### 権限チェック (ページレベル)

```typescript
// frontend/src/lib/auth.ts
export async function getCurrentUser() {
  const token = cookies().get("access_token")?.value;
  if (!token) return null;
  
  // Server Action で、Backend に JWT 検証をリクエスト
  const response = await fetch(`${API_BASE_URL}/auth/me`, {
    headers: { Authorization: `Bearer ${token}` },
  });
  
  return await response.json();
}

// frontend/src/app/circles/[id]/edit/page.tsx
export default async function CircleEditPage() {
  const user = await getCurrentUser();
  if (!user) return <Redirect to="/login" />;
  
  // Backend が権限チェックをして、ユーザー情報 + 権限フラグを返す
  if (!user.can_edit_circles) return <Forbidden />;
  
  return <CircleEditForm />;
}
```

**トークン管理の原則:**
  * `access_token` (短命): API リクエストに含める
  * `refresh_token` (長命): アクセストークン更新時のみ使用、ブラウザに公開しない
  * `client_secret`: Backend (Next.js API Route) でのみ保管・使用、ブラウザに公開しない

### 6.4. デザインシステム (shadcn/ui)

  * **コンポーネント:** `src/components/ui` 配下のコンポーネントを使用。
  * **アイコン:** **Lucide React** を使用。
  * **スタイリング:** **Tailwind CSS** を使用。

### 6.5. 画面遷移図 (Site Map)

2つのサイトは**物理的に分離**しており、ログインボタンで相互に遷移する。

```mermaid
graph TB
    subgraph StaticSite["静的サイト (外部公開用) - https://circles.lcn.ad.jp"]
        STop[トップページ]
        SList[サークル一覧]
        SDetail[サークル詳細 - 基本情報のみ]
        
        STop -->|八王子ボタン| SList
        STop -->|蒲田ボタン| SList
        STop -->|最近更新| SDetail
        SList --> SDetail
    end
    
    subgraph LoginApp["学内アプリ - https://portal.circles.lcn.ad.jp"]
        LDash[ダッシュボード]
        LList[サークル一覧 - 全情報]
        LDetail[サークル詳細 - 全情報]
        LEdit[サークル編集]
        LAnnounceList[お知らせ一覧]
        LAnnounceNew[お知らせ新規作成]
        LAnnounceEdit[お知らせ編集]
        LAdmin[システム管理]
        
        LDash --> LList
        LDash -->|SystemAdmin| LAdmin
        LList --> LDetail
        LDetail -->|Leader/Editor| LEdit
        LDetail --> LAnnounceList
        LAnnounceList -->|Leader/Editor| LAnnounceNew
        LAnnounceList -->|編集| LAnnounceEdit
    end
    
    Auth[Keycloak 認証]
    
    STop -.->|ログインボタン| Auth
    SDetail -.->|詳細を見る| Auth
    Auth -->|認証成功| LDash
    
    LDash -.->|静的サイトへ| STop
```

**設計意図:**
- **静的サイト**: 検索エンジン最適化(SEO)、高速表示、DB負荷軽減
- **学内アプリ**: 機能性重視、リアルタイム更新、権限管理
- **分離のメリット**: セキュリティ向上、運用負荷の分散、障害時の影響範囲限定

-----

## 7\. 開発環境・ワークフロー (Development Environment & Workflow)

開発チーム全員が統一された環境で効率的に作業を進めるためのツールセットとルールを定義する。

### 7.1. 必須ツールセット (Toolchain)

環境差異によるバグを防ぐため、以下のツール導入を必須とする。

| カテゴリ | ツール | 用途・運用ルール |
| :--- | :--- | :--- |
| **環境管理** | **mise** | 言語バージョン管理 (`node`, `python`) およびタスクランナーとして使用。<br>`mise.toml` にバージョンを固定し、全員が同じ環境を再現できるようにする。 |
| **Python管理** | **uv** | 高速なパッケージ管理・仮想環境作成に使用。<br>`pip` や `poetry` の代わりに使用する (`uv sync` 等)。 |
| **Node管理** | **npm** | フロントエンドのパッケージ管理。Node本体は `mise` で管理する。 |
| **Container** | **Docker** | DB (PostgreSQL) や S3 (MinIO) などのミドルウェア起動に使用。<br>Compose V2 (`docker compose`) を前提とする。 |
| **VCS** | **Git / GitHub** | バージョン管理。 |
| **Testing** | **pytest / Vitest** | BEは `pytest`、FEは `Vitest` を使用する。 |

### 7.2. エディタ・AI支援

  * **Editor:** **VS Code** (Visual Studio Code) を推奨。
      * **推奨拡張機能:**
          * Python (Microsoft)
          * Pylance
          * ES7+ React/Redux/React-Native snippets
          * Tailwind CSS IntelliSense
          * Pretty TypeScript Errors
  * **AI Pair Programmer:** **GitHub Copilot**
      * ボイラープレートコード（定型文）の生成や、テストコードの作成に積極活用する。
      * **注意:** 生成されたコードは必ず人間が内容を理解し、セキュリティやロジックに問題がないか確認してからコミットすること。

### 7.3. バージョン管理フロー (GitHub Flow)

シンプルで迅速な開発サイクルを回すため、**GitHub Flow** を採用する。

1.  **Main Branch:** 常にデプロイ可能な状態を保つ。直接コミットは禁止。
2.  **Feature Branch:** `main` から分岐して作業する。
      * 命名規則: `feature/機能名` (例: `feature/add-login`, `fix/typo-circle-list`)
3.  **Pull Request (PR):** 作業が完了したら `main` へ向けてPRを作成する。
      * PR作成時、自動テストやLintチェック（CI）が通ることを確認する。
      * 原則として、開発者自身以外の**1名以上のReview**を通してからマージする。
4.  **Merge:** マージ後はブランチを削除する。

### 7.4. コミットメッセージ規約

後から履歴を追いやすくするため、**Conventional Commits** に準じたプレフィックスを付けることを推奨する。

  * `feat:` 新機能 (feature)
  * `fix:` バグ修正 (bug fix)
  * `docs:` ドキュメントのみの変更
  * `style:` コードの動作に影響しない変更（空白、フォーマット等）
  * `refactor:` リファクタリング（機能追加もバグ修正も含まないコード変更）
  * `test:` テストコードの追加・修正
  * `chore:` その他、ビルドプロセスやツールの変更など

### 7.5. 便利コマンド (mise tasks)

開発効率化のため、`mise.toml` に以下のタスクを定義しておく（例）。

  * `mise run dev`: Docker(DB)を起動し、BackendとFrontendの開発サーバーを同時に立ち上げる。
  * `mise run test`: BackendとFrontendのテストを一括実行する。
  * `mise run setup`: 依存ライブラリのインストール (`uv sync`, `npm install`) を一括で行う。

### 7.6. テスト戦略とTDD (Test-Driven Development) (推奨)

品質担保とリファクタリングの心理的安全性確保のため、**テスト駆動開発(TDD)** の考え方を取り入れる。

#### 7.6.1. バックエンド (FastAPI + pytest)

**APIの挙動を保証するため、エンドポイント単位のテスト実装を必須とする。**

  * **ツール:** `pytest`, `httpx` (AsyncClient)
  * **方針:**
    1.  **Red (失敗):** 実装前に、「期待するレスポンス（正常系・異常系）」を定義したテストコードを書く。
          * 例: 「一般ユーザーがサークル削除APIを叩いたら 403 Forbidden が返ること」を確認するテスト。
    2.  **Green (成功):** テストが通るようにAPIを実装する。
    3.  **Refactor:** コードを綺麗にする。
  * **対象:** APIエンドポイント (`api/v1/endpoints/`)、複雑なビジネスロジック (`services/`)。

#### 7.6.2. フロントエンド (Next.js + Vitest)

**ロジックの正しさを保証するため、ユーティリティ関数等のユニットテストを推奨する。**

  * **ツール:** `Vitest` (Jestよりも高速で設定が楽なため採用)
  * **方針:**
      * UIコンポーネントの見た目のテストはコストが高いため必須としない。
      * `lib/utils.ts` 内の関数や、複雑なフックのロジックはテスト対象とする。

---

## 8. Keycloak セットアップ・運用ガイド

### 8.1. Docker Compose での Keycloak 起動

#### 8.1.0. mise tasks との連携

このプロジェクトでは `mise` をタスクランナーとして使用します。

**関連する mise tasks:**

| コマンド | 説明 | 実行内容 |
|---------|------|--------|
| `mise run infra` | インフラ起動 | `docker compose up -d` で PostgreSQL と Keycloak を起動 |
| `mise run dev` | 開発サーバ起動 | 上記に加えて FastAPI Backend と Next.js Frontend も起動 |
| `mise run down` | 全サービス停止 | `docker compose down` で全コンテナを停止 |
| `mise run db-reset` | DB リセット | Keycloak を含むすべてのデータを削除して初期化 |

**開発フロー例:**

```bash
# 1. 初回セットアップ
mise run setup       # 依存ライブラリ インストール

# 2. 開発環境起動
mise run dev         # インフラ (PostgreSQL + Keycloak) + Backend + Frontend を同時起動

# 3. ブラウザで確認
# - Frontend: http://localhost:3000
# - Backend API: http://localhost:8000
# - Keycloak Admin: http://localhost:8080/admin (admin/admin)

# 4. 終了
mise run down        # 全サービス停止

# 5. DB リセット (開発中のテストデータを全削除)
mise run db-reset
```

#### 8.1.1. compose.yml への設定追加

プロジェクトの `compose.yml` に以下を追加（開発環境用）。**注:** このファイルは既にプロジェクトに存在します。Keycloak サービスの設定が以下のように記載されていることを確認してください。

```yaml
services:
  # PostgreSQL (既存)
  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: circleportal
      POSTGRES_USER: circleportal
      POSTGRES_PASSWORD: password
    volumes:
      - db_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
  
  # Keycloak 26 LTS
  keycloak:
    image: quay.io/keycloak/keycloak:26.0.0
    environment:
      KC_DB: postgres
      KC_DB_URL: jdbc:postgresql://db:5432/keycloak
      KC_DB_USERNAME: keycloak
      KC_DB_PASSWORD: keycloak_password
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: admin
      KC_PROXY: edge
      KC_HOSTNAME: localhost
      KC_HOSTNAME_PORT: 8080
      KC_HOSTNAME_PROTOCOL: http
    command: start-dev
    ports:
      - "8080:8080"
    depends_on:
      - db
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health/ready"]
      interval: 10s
      timeout: 5s
      retries: 5
  
  # FastAPI Backend
  backend:
    build: ./backend
    environment:
      DATABASE_URL: postgresql+asyncpg://circleportal:password@db:5432/circleportal
      KEYCLOAK_URL: http://keycloak:8080
      KEYCLOAK_REALM: CirclePortal-dev
      KEYCLOAK_CLIENT_ID: circle-portal-backend
      KEYCLOAK_CLIENT_SECRET: ${KEYCLOAK_CLIENT_SECRET}
    ports:
      - "8000:8000"
    depends_on:
      keycloak:
        condition: service_healthy

volumes:
  db_data:
```

#### 8.1.2. 環境変数ファイル (.env)

プロジェクトルートに `.env` ファイルを作成:

```bash
# Keycloak
KEYCLOAK_URL=http://localhost:8080
KEYCLOAK_REALM=CirclePortal-dev
KEYCLOAK_CLIENT_ID=circle-portal-frontend
KEYCLOAK_CLIENT_SECRET=your-client-secret-here

# Frontend (Next.js)
NEXT_PUBLIC_API_URL=http://localhost:8000
NEXT_PUBLIC_KEYCLOAK_URL=http://localhost:8080
NEXT_PUBLIC_KEYCLOAK_REALM=CirclePortal-dev
NEXT_PUBLIC_KEYCLOAK_CLIENT_ID=circle-portal-frontend

# Backend
DATABASE_URL=postgresql+asyncpg://circleportal:password@localhost:5432/circleportal
```

#### 8.1.3. 起動コマンド

**開発環境での起動 (推奨):**

```bash
# 全サービス起動 (インフラ + Backend + Frontend)
mise run dev
```

または、個別に起動する場合:

```bash
# インフラ (PostgreSQL + Keycloak) のみ起動
mise run infra

# Backend 起動 (別ターミナル)
mise run backend

# Frontend 起動 (別ターミナル)
mise run frontend
```

起動完了後、以下の URL でアクセス可能:

| サービス | URL | 認証情報 |
|---------|-----|--------|
| Keycloak Admin Console | `http://localhost:8080/admin/master/console/` | admin / admin |
| Frontend アプリケーション | `http://localhost:3000` | (Keycloak でログイン) |
| Backend API (Swagger) | `http://localhost:8000/docs` | (JWT認証) |

### 8.2. Keycloak の初期セットアップ

#### 8.2.1. Admin Console へのログイン

1. `http://localhost:8080/admin/master/console/` にアクセス
2. ユーザー名: `admin`, パスワード: `admin` でログイン
3. (本番環境ではパスワードを強力なものに変更すること)

#### 8.2.2. レルムの作成

1. 左上の「Keycloak」アイコンの右隣、「master」をクリック
2. 「Create Realm」をクリック
3. **Realm Name:** `CirclePortal-dev`
4. 「Create」をクリック

#### 8.2.3. Client の作成

**クライアント名:** `circle-portal-frontend`

1. レルム `CirclePortal-dev` を選択
2. 左メニュー → 「Clients」
3. 「Create client」をクリック
4. **Client ID:** `circle-portal-frontend`
5. 「Next」をクリック
6. **Capability config:**
   - ✓ Standard flow
   - ✓ Direct access grants (optional)
   - (SAML は不要)
7. 「Next」をクリック
8. **Login settings:**
   - **Root URL:** `http://localhost:3000`
   - **Home URL:** `http://localhost:3000`
   - **Valid redirect URIs:** `http://localhost:3000/api/auth/callback`
   - **Valid post logout redirect URIs:** `http://localhost:3000`
   - **Web origins:** `http://localhost:3000`
9. 「Save」をクリック
10. 「Credentials」タブを選択し、**Client Secret** をコピー (`.env` に貼り付け)

**クライアント名:** `circle-portal-backend`

同様の手順で Backend 用クライアントを作成:

1. **Client ID:** `circle-portal-backend`
2. **Capability config:**
   - ✓ Service accounts roles
   - (Standard flow は不要)
3. **Service account roles:**
   - 「Service Accounts Roles」タブ
   - 「Assign role」で `realm-management` の `view-users`, `manage-users` をアサイン (オプション)
4. **Credentials** で Client Secret をコピー

#### 8.2.4. ロール (Role) の定義

1. 左メニュー → 「Realm Roles」
2. 「Create role」をクリック
3. **Role name:** `system_admin`
4. 「Create」をクリック
5. 同様に `general` ロールも作成

#### 8.2.5. ユーザーの作成

**テストユーザー (システム管理者):**

1. 左メニュー → 「Users」
2. 「Create new user」をクリック
3. **Username:** `admin_user`
4. **Email:** `admin@edu.teu.ac.jp`
5. **Email Verified:** ON
6. 「Create」をクリック
7. 「Credentials」タブ → 「Set password」で仮パスワードを設定
8. 「Role mapping」タブ:
   - 「Assign role」で `system_admin` をアサイン

**テストユーザー (一般ユーザー):**

1. **Username:** `user_test`
2. **Email:** `user@edu.teu.ac.jp`
3. 「Role mapping」タブで `general` をアサイン

### 8.3. JWT の確認・デバッグ

#### 8.3.1. Token 取得テスト

```bash
# Authorization Code Flow を手動でテスト
curl -X POST http://localhost:8080/realms/CirclePortal-dev/protocol/openid-connect/token \
  -d "grant_type=password" \
  -d "client_id=circle-portal-frontend" \
  -d "client_secret=<CLIENT_SECRET>" \
  -d "username=admin_user" \
  -d "password=<PASSWORD>" \
  -d "scope=openid email profile"
```

レスポンス:

```json
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR5cC...",
  "expires_in": 300,
  "refresh_expires_in": 1800,
  "refresh_token": "eyJhbGciOiJSUzI1NiIsInR5cC...",
  "token_type": "Bearer",
  "id_token": "eyJhbGciOiJSUzI1NiIsInR5cC..."
}
```

#### 8.3.2. JWT のデコード

```bash
# Payload をデコード (署名検証なし、確認用)
echo "<access_token>" | cut -d. -f2 | base64 -d | jq .
```

出力例:

```json
{
  "iss": "http://localhost:8080/realms/CirclePortal-dev",
  "sub": "550e8400-e29b-41d4-a716-446655440000",
  "email": "admin@edu.teu.ac.jp",
  "email_verified": true,
  "name": "Admin User",
  "resource_access": {
    "circle-portal-frontend": {
      "roles": ["system_admin"]
    }
  },
  "iat": 1702099200,
  "exp": 1702102800
}
```

### 8.4. Backend (FastAPI) での JWT 検証実装

公開鍵の取得とキャッシュ:

```python
# backend/app/core/security.py

from jose import JWTError, jwt
import httpx
from functools import lru_cache

KEYCLOAK_URL = os.getenv("KEYCLOAK_URL")
KEYCLOAK_REALM = os.getenv("KEYCLOAK_REALM")
ALGORITHMS = ["RS256"]

@lru_cache(maxsize=1)
async def get_public_keys():
    """Keycloak の公開鍵セット (JWKS) を取得・キャッシュ"""
    async with httpx.AsyncClient() as client:
        response = await client.get(
            f"{KEYCLOAK_URL}/realms/{KEYCLOAK_REALM}/protocol/openid-connect/certs"
        )
        return response.json()

def get_public_key(token: str) -> str:
    """JWT のヘッダから kid (Key ID) を取得し、対応する公開鍵を返す"""
    unverified_header = jwt.get_unverified_header(token)
    kid = unverified_header.get("kid")
    
    keys = asyncio.run(get_public_keys())
    for key in keys["keys"]:
        if key["kid"] == kid:
            return jwt.algorithms.RSAAlgorithm.from_jwk(json.dumps(key))
    
    raise HTTPException(status_code=401, detail="Invalid key ID")

async def get_current_user(authorization: str = Header(...)) -> dict:
    """
    Authorization ヘッダから JWT を抽出し、検証してユーザー情報を取得
    """
    if not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Missing or invalid authorization header")
    
    token = authorization.split(" ", 1)[1]
    
    try:
        public_key = get_public_key(token)
        payload = jwt.decode(token, public_key, algorithms=ALGORITHMS)
        user_id: str = payload.get("sub")
        email: str = payload.get("email")
        roles: list = payload.get("resource_access", {}).get("circle-portal-frontend", {}).get("roles", [])
        
        return {
            "user_id": user_id,
            "email": email,
            "roles": roles,
            "is_admin": "system_admin" in roles,
        }
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")
```

### 8.5. 本番環境への移行チェックリスト

本番運用時には以下を実施:

- [ ] Keycloak バージョンを 26 LTS に固定
- [ ] 管理者パスワードを強力なものに変更
- [ ] HTTPS (TLS) を有効化
- [ ] レルム名を `CirclePortal-prod` に変更
- [ ] `@edu.teu.ac.jp` ドメイン制限の設定
- [ ] LDAP/User Federation の設定 (学務システムとの連携)
- [ ] バックアップスケジュールの設定
- [ ] ログの集約設定 (ELK Stack 等)
- [ ] Secret rotation ポリシーの制定
